/* File generated by Beremiz (PlugGenerate_C method of Modbus plugin) */

/*
 * Copyright (c) 2016 Mario de Sousa (msousa@fe.up.pt)
 *
 * This file is part of the Modbus library for Beremiz and matiec.
 *
 * This Modbus library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser 
 * General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this Modbus library.  If not, see <http://www.gnu.org/licenses/>.
 *
 * This code is made available on the understanding that it will not be
 * used in safety-critical situations without a full and competent review.
 */

#ifdef ARDUINO
#include <Arduino.h>
#include <core_debug.h>
#endif
#include <stdio.h>
#include "MB_%(locstr)s.h"
#include <string.h> /* required for memcpy() */

#define __LOCATED_VAR(type, name, lt, lsz, io_proto, ...) \
	extern type *name;
#include "LOCATED_VARIABLES.h"
#undef __LOCATED_VAR
void __mb_client_thread(const void *arg);
void __mb_server_thread(const void *arg);
void s1234_L(const char *s, char *d);
void s1234_D(const char *s, char *d);
void s1234_W(const char *s, char *d);
void s1234_B(const char *s, char *d);
void s1234_X(const char *s, char *d);
void s4321_D(const char *s, char *d);
void s4321_W(const char *s, char *d);
void s4321_B(const char *s, char *d);
void s4321_X(const char *s, char *d);
void s2143_D(const char *s, char *d);
void s2143_W(const char *s, char *d);
void s2143_B(const char *s, char *d);
void s2143_X(const char *s, char *d);
void s3412_D(const char *s, char *d);
void s3412_W(const char *s, char *d);
void s3412_X(const char *s, char *d);
void s3412_B(const char *s, char *d);

extern "C"
{
int __cleanup_%(locstr)s();
int __init_%(locstr)s()
	{
		int index;

    %(init)s

		for (index = 0; index < NUMBER_OF_CLIENT_NODES; index++)
			client_nodes[index].mb_nd = -1;
		for (index = 0; index < NUMBER_OF_SERVER_NODES; index++)
			// mb_nd with negative numbers indicate how far it has been initialised (or not)
			//   -2  --> no modbus node created;  no thread  created
			//   -1  -->    modbus node created!; no thread  created
			//  >=0  -->    modbus node created!;    thread  created!
			server_nodes[index].mb_nd = -2;

		/* modbus library init */
		/* Note that TOTAL_xxxNODE_COUNT are the nodes required by _ALL_ the instances of the modbus
	 *  extension currently in the user's project. This file (MB_xx.c) is handling only one instance,
	 *  but must initialize the library for all instances. Only the first call to mb_slave_and_master_init()
	 *  will result in memory being allocated. All subsequent calls (by other MB_xx,c files) will be ignored
	 *  by the mb_slave_and_master_init() funtion, as long as they are called with the same arguments.
	 */
		if (plc_rte->mb_abi->mb_slave_and_master_init(TOTAL_TCPNODE_COUNT, TOTAL_RTUNODE_COUNT, TOTAL_ASCNODE_COUNT) < 0)
		{
			Log(LOG_CRITICAL, "Modbus plugin: Error starting modbus library\n");
			// return imediately. Do NOT goto error_exit, as we did not get to
			//  start the modbus library!
			return -1;
		}

		/* init the mutex for each client request */
		/* Must be done _before_ launching the client threads!! */
		for (index = 0; index < NUMBER_OF_CLIENT_REQTS; index++)
		{
			if (plc_rte->mb_request_abi->mb_request_init(&(client_requests[index])))
			{
				goto error_exit;
			}
		}

		/* init each client connection to remote modbus server, and launch thread */
		/* NOTE: All client_nodes[].init_state are initialised to 0 in the code 
	 *       generated by the modbus plugin 
	 */
		for (index = 0; index < NUMBER_OF_CLIENT_NODES; index++)
		{
			/* establish client connection */
			client_nodes[index].mb_nd = plc_rte->mb_master_abi->mb_master_connect(&client_nodes[index]);
			if (client_nodes[index].mb_nd < 0)
			{
				Log(LOG_CRITICAL, "Modbus plugin: Error creating modbus client node %%s\n", client_nodes[index].location);
				goto error_exit;
			}
			client_nodes[index].init_state = 1; // we have created the node

			/* launch a thread to handle this client node */
			client_nodes[index].init_state = 2; // we have created the node and a thread
		}

		/* init each local server */
		/* NOTE: All server_nodes[].init_state are initialised to 0 in the code 
	 *       generated by the modbus plugin 
	 */
		for (index = 0; index < NUMBER_OF_SERVER_NODES; index++)
		{
			/* create the modbus server */
			server_nodes[index].mb_nd = plc_rte->mb_slave_abi->mb_slave_init(&server_nodes[index]);
			if (server_nodes[index].mb_nd < 0)
			{
				Log(LOG_CRITICAL, "Modbus plugin: Error creating modbus server node %%s\n", server_nodes[index].location);
				goto error_exit;
			}
			server_nodes[index].init_state = 1; // we have created the node

			/* launch a thread to handle this server node */
			server_nodes[index].init_state = 2; // we have created the node and thread
		}

	return 0;

error_exit:
	__cleanup_%(locstr)s();
	return -1;
}

void __publish_%(locstr)s()
{
	int index;
    %(publish)s
	for (index = 0; index < NUMBER_OF_CLIENT_REQTS; index++)
	{
		/*just do the output requests */
		if (client_requests[index].req_type == req_output)
		{
				if (plc_rte->mb_request_abi->mb_request_lock(&(client_requests[index])) == 1)
				{
					// copy from plcv_buffer to coms_buffer
					memcpy((void *)client_requests[index].coms_buffer /* destination */,
						   (void *)client_requests[index].plcv_buffer /* source */,
						   client_requests[index].count * sizeof(uint16_t) /* size in bytes */);
					plc_rte->mb_request_abi->mb_request_unlock(&(client_requests[index]));
				}
			}
		}
	}

void __retrieve_%(locstr)s()
{
	int index;
	for (index = 0; index < NUMBER_OF_CLIENT_REQTS; index++)
	{
		/*just do the input requests */
		if (client_requests[index].req_type == req_input)
		{
				if (plc_rte->mb_request_abi->mb_request_lock(&(client_requests[index])) == 1)
				{
					// copy from coms_buffer to plcv_buffer
					memcpy((void *)client_requests[index].plcv_buffer /* destination */,
						   (void *)client_requests[index].coms_buffer /* source */,
						   client_requests[index].count * sizeof(uint16_t) /* size in bytes */);
					plc_rte->mb_request_abi->mb_request_unlock(&(client_requests[index]));
				}
			}
		}
    %(retrieve)s
}

int __cleanup_%(locstr)s()
{
	int index, close;
	int res = 0;

		/* kill thread and close connections of each modbus client node */
		for (index = 0; index < NUMBER_OF_CLIENT_NODES; index++)
		{
			close = 0;
			if (client_nodes[index].init_state >= 2)
			{
				// thread was launched, so we try to cancel it!
				client_nodes[index].init_state = 0xaa;
				plc_rte->delay(1100);
				close = 0;
				 if (close < 0)
				Log(LOG_CRITICAL, "Modbus plugin: Error closing thread for modbus client %%s\n", client_nodes[index].location);
			}
			res |= close;

			close = 0;
			if (client_nodes[index].init_state >= 1)
			{
				// modbus client node was created, so we try to close it!
				close = plc_rte->mb_master_abi->mb_master_close(&client_nodes[index]);
				if (close < 0)
				{
					Log(LOG_CRITICAL, "Modbus plugin: Error closing modbus client node %%s\n", client_nodes[index].location);
					// We try to shut down as much as possible, so we do not return noW!
				}
				client_nodes[index].mb_nd = -1;
			}
			res |= close;
			client_nodes[index].init_state = 0;
		}

		/* kill thread and close connections of each modbus server node */
		for (index = 0; index < NUMBER_OF_SERVER_NODES; index++)
		{
			close = 0;
			if (server_nodes[index].init_state >= 2)
			{
				client_nodes[index].init_state = 0xaa;
				plc_rte->delay(1100);
				close = 0;
				close = plc_rte->mb_slave_abi->mb_slave_close(&server_nodes[index]);
				if (close < 0)
				Log(LOG_CRITICAL, "Modbus plugin: Error closing thread for modbus server %%s\n", server_nodes[index].location);
		}
		res |= close;

			close = 0;
			if (server_nodes[index].init_state >= 1)
			{
				// modbus server node was created, so we try to close it!
				close = plc_rte->mb_slave_abi->mb_slave_close(&server_nodes[index]);
				if (close < 0)
				{
					Log(LOG_CRITICAL, "Modbus plugin: Error closing node for modbus server %%s (%%d)\n", server_nodes[index].location, server_nodes[index].mb_nd);
					// We try to shut down as much as possible, so we do not return noW!
				}
				server_nodes[index].mb_nd = -1;
			}
			res |= close;
			server_nodes[index].init_state = 0;
		}

		/* destroy the mutex of each client request */
		for (index = 0; index < NUMBER_OF_CLIENT_REQTS; index++)
		{
			if (plc_rte->mb_request_abi->mb_request_close(&(client_requests[index])))
			{
				Log(LOG_CRITICAL, "Modbus plugin: Error destroying request for modbus client node %%s\n", client_nodes[client_requests[index].client_node_id].location);
				// We try to shut down as much as possible, so we do not return noW!
				res |= -1;
			}
		}

		/* modbus library close */
		Log(LOG_INFO, "Shutting down modbus library...\n");
		if (plc_rte->mb_abi->mb_slave_and_master_done() < 0)
		{
			Log(LOG_CRITICAL, "Modbus plugin: Error shutting down modbus library\n");
			res |= -1;
		}

		return res;
	}
}