#!/usr/bin/env python
# -*- coding: utf-8 -*-
import shutil
import socket

__version__ = "$Revision$"

import os, sys, getopt, wx, tempfile
import __builtin__
from types import TupleType, StringType, UnicodeType

CWD = os.path.split(os.path.realpath(__file__))[0]

def Bpath(*args):
    return os.path.join(CWD,*args)

if __name__ == '__main__':
    def usage():
        print "\nUsage of LPCBeremiz.py :"
        print "\n   %s Projectpath Buildpath port\n"%sys.argv[0]
    
    try:
        opts, args = getopt.getopt(sys.argv[1:], "h", ["help"])
    except getopt.GetoptError:
        # print help information and exit:
        usage()
        sys.exit(2)
    
    for o, a in opts:
        if o in ("-h", "--help"):
            usage()
            sys.exit()
    
    if len(args) != 3:
        usage()
        sys.exit()
    else:
        projectOpen = args[0]
        buildpath = args[1]
        try:
            port = int(args[2])
        except:
            usage()
            sys.exit()

    if os.path.exists("LPC_DEBUG"):
        __builtin__.__dict__["BMZ_DBG"] = True
    else :
        __builtin__.__dict__["BMZ_DBG"] = False

app = wx.PySimpleApp(redirect=BMZ_DBG)
app.SetAppName('beremiz')
wx.InitAllImageHandlers()

# Import module for internationalization
import gettext

if __name__ == '__main__':
    __builtin__.__dict__['_'] = wx.GetTranslation#unicode_translation

from Beremiz import *
from plugger import PluginsRoot, PlugTemplate, opjimg, connectors
from plcopen.structures import LOCATIONDATATYPES
from PLCControler import LOCATION_PLUGIN, LOCATION_MODULE, LOCATION_GROUP,\
                         LOCATION_VAR_INPUT, LOCATION_VAR_OUTPUT, LOCATION_VAR_MEMORY
from PLCOpenEditor import IDEFrame, ProjectDialog

havecanfestival = False
try:
    from plugins.canfestival import RootClass as CanOpenRootClass
    from plugins.canfestival.canfestival import _SlavePlug, _NodeListPlug, NodeManager
    havecanfestival = True
except:
    havecanfestival = False
    

#-------------------------------------------------------------------------------
#                          CANFESTIVAL PLUGIN HACK
#-------------------------------------------------------------------------------
# from plugins.canfestival import canfestival
# class LPC_canfestival_config:
#     def getCFLAGS(self, *args):
#         return ""
# 
#     def getLDFLAGS(self, *args):
#         return ""
#         
# canfestival.local_canfestival_config = LPC_canfestival_config() 
#-------------------------------------------------------------------------------
#                              LPCModule Class
#-------------------------------------------------------------------------------

LOCATION_TYPES = {"I": LOCATION_VAR_INPUT,
                  "Q": LOCATION_VAR_OUTPUT,
                  "M": LOCATION_VAR_MEMORY}

LOCATION_DIRS = dict([(dir, size) for size, dir in LOCATION_TYPES.iteritems()])

LOCATION_SIZES = {}
for size, types in LOCATIONDATATYPES.iteritems():
    for type in types:
        LOCATION_SIZES[type] = size

def _GetModuleChildren(module):
    children = []
    for child in module["children"]:
        if child["type"] == LOCATION_GROUP:
            children.extend(child["children"])
        else:
            children.append(child)
    return children

def _GetVariables(module):
    variables = []
    for child in module["children"]:
        if child["type"] in [LOCATION_GROUP, LOCATION_MODULE]:
            variables.extend(_GetVariables(child))
        else:
            variables.append(child)
    return variables

def _GetLastModuleGroup(module):
    group = module
    for child in module["children"]:
        if child["type"] == LOCATION_GROUP:
            group = child
    return group["children"]

def _GetModuleBySomething(module, something, toks):
    for child in _GetModuleChildren(module):
        if child.get(something) == toks[0]:
            if len(toks) > 1:
                return _GetModuleBySomething(child, something, toks[1:])
            return child
    return None

def _GetModuleVariable(module, location, direction):
    for child in _GetModuleChildren(module):
        if child["location"] == location and child["type"] == LOCATION_TYPES[direction]:
            return child
    return None

def _RemoveModuleChild(module, child):
    if child in module["children"]:
        module["children"].remove(child)
    else:
        for group in module["children"]:
            if group["type"] == LOCATION_GROUP and child in group["children"]:
                group["children"].remove(child)

BUS_TEXT = """/* Code generated by LPCBus plugin */

/* LPCBus plugin includes */
#include "app_glue.h"
#ifdef _WINDOWS_H
  #include "iec_types.h"
#else
  #include "iec_std_lib.h"
#endif

%(declare_code)s

/* LPCBus plugin user variables definition */
%(var_decl)s

/* LPCBus plugin functions */
int __init_%(location_str)s(int argc,char **argv)
{
%(init_code)s
  return 0;
}

void __cleanup_%(location_str)s(void)
{
}

void __retrieve_%(location_str)s(void)
{
%(retrieve_code)s
}
        
void __publish_%(location_str)s(void)
{
%(publish_code)s
}
"""

class LPCBus(object):
    
    def __init__(self):
        self.VariableLocationTree = []
        self.ResetUsedLocations()
        self.Icon = None
    
    def __getitem__(self, key):
        if key == "children":
            return self.VariableLocationTree
        raise KeyError, "Only 'children' key is available"
    
    def PlugEnabled(self):
        return None
    
    def SetIcon(self, icon):
        self.Icon = icon
    
    def _GetChildBySomething(self, something, toks):
        return _GetModuleBySomething({"children" : self.VariableLocationTree}, something, toks)
    
    def GetBaseTypes(self):
        return self.GetPlugRoot().GetBaseTypes()

    def GetSizeOfType(self, type):
        return LOCATION_SIZES[self.GetPlugRoot().GetBaseType(type)]
    
    def _GetVariableLocationTree(self, current_location, infos):
        if infos["type"] == LOCATION_MODULE:
            location = current_location + (infos["IEC_Channel"],)
            return {"name": infos["name"],
                    "type": infos["type"],
                    "location": ".".join(map(str, location + ("x",))), 
                    "icon": infos["icon"], 
                    "children": [self._GetVariableLocationTree(location, child) for child in infos["children"]]}
        elif infos["type"] == LOCATION_GROUP:
            return {"name": infos["name"],
                    "type": infos["type"],
                    "location": "", 
                    "icon": infos["icon"], 
                    "children": [self._GetVariableLocationTree(current_location, child) for child in infos["children"]]}
        else:
            size = self.GetSizeOfType(infos["IEC_type"])
            location = "%" + LOCATION_DIRS[infos["type"]] + size + ".".join(map(str, current_location + infos["location"]))
            return {"name": infos["name"],
                    "type": infos["type"],
                    "size": size,
                    "IEC_type": infos["IEC_type"],
                    "var_name": infos["name"],
                    "location": location,
                    "description": infos["description"],
                    "children": []}
    
    def GetVariableLocationTree(self):
        return {"name": self.BaseParams.getName(),
                "type": LOCATION_PLUGIN,
                "location": self.GetFullIEC_Channel(),
                "icon": self.Icon, 
                "children": [self._GetVariableLocationTree(self.GetCurrentLocation(), child) 
                             for child in self.VariableLocationTree]}
    
    def PlugTestModified(self):
        return False

    def PlugMakeDir(self):
        pass

    def PlugRequestSave(self):
        return None

    def ResetUsedLocations(self):
        self.UsedLocations = {}
    
    def _AddUsedLocation(self, parent, location):
        num = location.pop(0)
        if not parent.has_key(num):
            parent[num] = {"used": False, "children": {}}
        if len(location) > 0:
            self._AddUsedLocation(parent[num]["children"], location)
        else:
            parent[num]["used"] = True
        
    def AddUsedLocation(self, location):
        if len(location) > 0:
            self._AddUsedLocation(self.UsedLocations, list(location))

    def _CheckLocationConflicts(self, parent, location):
        num = location.pop(0)
        if not parent.has_key(num):
            return False
        if len(location) > 0:
            if parent[num]["used"]:
                return True
            return self._CheckLocationConflicts(parent[num]["children"], location)
        elif len(parent[num]["children"]) > 0:
            return True
        return False

    def CheckLocationConflicts(self, location):
        if len(location) > 0:
            return self._CheckLocationConflicts(self.UsedLocations, list(location))
        return False

    def PlugGenerate_C(self, buildpath, locations):
        """
        Generate C code
        @param current_location: Tupple containing plugin IEC location : %I0.0.4.5 => (0,0,4,5)
        @param locations: List of complete variables locations \
            [{"IEC_TYPE" : the IEC type (i.e. "INT", "STRING", ...)
            "NAME" : name of the variable (generally "__IW0_1_2" style)
            "DIR" : direction "Q","I" or "M"
            "SIZE" : size "X", "B", "W", "D", "L"
            "LOC" : tuple of interger for IEC location (0,1,2,...)
            }, ...]
        @return: [(C_file_name, CFLAGS),...] , LDFLAGS_TO_APPEND
        """
        current_location = self.GetCurrentLocation()
        # define a unique name for the generated C file
        location_str = "_".join(map(str, current_location))
        
        code_str = {"location_str": location_str,
                    "var_decl": "",
                    "declare_code": "",
                    "init_code": "",
                    "retrieve_code": "",
                    "publish_code": "",
                   }
        
        for module in _GetModuleChildren(self):
            if module["init"] != "":
                code_str["init_code"] += "  %s\n" % module["init"]
        
        # Adding variables
        vars = []
        self.ResetUsedLocations()
        for location in locations:
            loc = location["LOC"][len(current_location):]
            group = next = self
            i = 0
            while next is not None and i < len(loc):
                next = self._GetChildBySomething("IEC_Channel", loc[:i + 1])
                if next is not None:
                    i += 1
                    group = next
            var_loc = loc[i:]
            for variable in _GetModuleChildren(group):
                if variable["location"] == var_loc and location["DIR"] == LOCATION_DIRS[variable["type"]]:
#                    if location["DIR"] != LOCATION_DIRS[variable["type"]]:
#                        raise Exception, "Direction conflict in variable definition"
#                    if location["IEC_TYPE"] != variable["IEC_type"]:
#                        raise Exception, "Type conflict in variable definition"
                    if location["DIR"] == "Q":
                        if self.CheckLocationConflicts(location["LOC"]):
                            raise Exception, "BYTE and BIT from the same BYTE can't be used together"
                        self.AddUsedLocation(location["LOC"])
                    vars.append({"location": location["NAME"],
                                 "Type": variable["IEC_type"],
                                 "Retrieve": variable["retrieve"],
                                 "Publish": variable["publish"],
                                })
                    break
        base_types = self.GetPlugRoot().GetBaseTypes()
        for var in vars:
            prefix = ""
            if var["Type"] in base_types:
                prefix = "IEC_"
            code_str["var_decl"] += "%s%s beremiz%s;\n"%(prefix, var["Type"], var["location"])
            code_str["var_decl"] += "%s%s *%s = &beremiz%s;\n"%(prefix, var["Type"], var["location"], var["location"])
            if var["Retrieve"] != "":
                code_str["retrieve_code"] += "  " + var["Retrieve"] % ("*" + var["location"]) + "\n"
            if var["Publish"] != "":
                code_str["publish_code"] += "  " + var["Publish"] % ("*" + var["location"]) + "\n"
        
        Gen_Module_path = os.path.join(buildpath, "Bus_%s.c"%location_str)
        module = open(Gen_Module_path,'w')
        module.write(BUS_TEXT % code_str)
        module.close()
        
        matiec_flags = '"-I%s"'%os.path.abspath(self.GetPlugRoot().GetIECLibPath())
        return [(Gen_Module_path, matiec_flags)],"",True

#-------------------------------------------------------------------------------
#                          LPC CanFestival Plugin Class
#-------------------------------------------------------------------------------

if havecanfestival:

    DEFAULT_SETTINGS = {
        "CAN_Baudrate": "125K",
        "Slave_NodeId": 2,
        "Master_NodeId": 1,
    }
    
    class LPCCanOpenSlave(_SlavePlug):
        XSD = """<?xml version="1.0" encoding="ISO-8859-1" ?>
        <xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">
          <xsd:element name="CanFestivalSlaveNode">
            <xsd:complexType>
              <xsd:attribute name="CAN_Baudrate" type="xsd:string" use="optional" default="%(CAN_Baudrate)s"/>
              <xsd:attribute name="NodeId" type="xsd:string" use="optional" default="%(Slave_NodeId)d"/>
              <xsd:attribute name="Sync_Align" type="xsd:integer" use="optional" default="0"/>
              <xsd:attribute name="Sync_Align_Ratio" use="optional" default="50">
                <xsd:simpleType>
                    <xsd:restriction base="xsd:integer">
                        <xsd:minInclusive value="1"/>
                        <xsd:maxInclusive value="99"/>
                    </xsd:restriction>
                </xsd:simpleType>
              </xsd:attribute>
            </xsd:complexType>
          </xsd:element>
        </xsd:schema>
        """ % DEFAULT_SETTINGS
        
        def __init__(self):
            # TODO change netname when name change
            NodeManager.__init__(self)
            odfilepath = self.GetSlaveODPath()
            if(os.path.isfile(odfilepath)):
                self.OpenFileInCurrent(odfilepath)
            else:
                self.CreateNewNode("SlaveNode",  # Name - will be changed at build time
                                   0x00,         # NodeID - will be changed at build time
                                   "slave",      # Type
                                   "",           # description 
                                   "None",       # profile
                                   "", # prfile filepath
                                   "heartbeat",  # NMT
                                   [])           # options
                self.OnPlugSave()
        
        def GetCanDevice(self):
            return str(self.BaseParams.getIEC_Channel())
        
    class LPCCanOpenMaster(_NodeListPlug):
        XSD = """<?xml version="1.0" encoding="ISO-8859-1" ?>
        <xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">
          <xsd:element name="CanFestivalNode">
            <xsd:complexType>
              <xsd:attribute name="CAN_Baudrate" type="xsd:string" use="optional" default="%(CAN_Baudrate)s"/>
              <xsd:attribute name="NodeId" type="xsd:string" use="optional" default="%(Master_NodeId)d"/>
              <xsd:attribute name="Sync_TPDOs" type="xsd:boolean" use="optional" default="true"/>
            </xsd:complexType>
          </xsd:element>
        </xsd:schema>
        """ % DEFAULT_SETTINGS
    
        def GetCanDevice(self):
            return str(self.BaseParams.getIEC_Channel())
    
    class LPCCanOpen(CanOpenRootClass):
        XSD = None
        PlugChildsTypes = [("CanOpenNode",LPCCanOpenMaster, "CanOpen Master"),
                           ("CanOpenSlave",LPCCanOpenSlave, "CanOpen Slave")]
        
        def GetCanDriver(self):
            return ""
        
        def LoadChilds(self):
            PlugTemplate.LoadChilds(self)
            
            if self.GetChildByName("Master") is None:
                master = self.PlugAddChild("Master", "CanOpenNode", 0)
                master.BaseParams.setEnabled(False)
            
            if self.GetChildByName("Slave") is None:
                slave = self.PlugAddChild("Slave", "CanOpenSlave", 1)
                slave.BaseParams.setEnabled(False)
    

#-------------------------------------------------------------------------------
#                              LPCPluginsRoot Class
#-------------------------------------------------------------------------------

def mycopytree(src, dst):
    """
    Copy content of a directory to an other, omit hidden files
    @param src: source directory
    @param dst: destination directory
    """
    for i in os.listdir(src):
        if not i.startswith('.') and i != "pous.xml":
            srcpath = os.path.join(src,i)
            dstpath = os.path.join(dst,i)
            if os.path.isdir(srcpath):
                if os.path.exists(dstpath):
                    shutil.rmtree(dstpath)
                os.makedirs(dstpath)
                mycopytree(srcpath, dstpath)
            elif os.path.isfile(srcpath):
                shutil.copy2(srcpath, dstpath)

[SIMULATION_MODE, TRANSFER_MODE] = range(2)

class LPCPluginsRoot(PluginsRoot):

    PluginMethods = [
        {"bitmap" : opjimg("Debug"),
         "name" : _("Simulate"),
         "tooltip" : _("Simulate PLC"),
         "method" : "_Simulate"},
        {"bitmap" : opjimg("Run"),
         "name" : _("Run"),
         "shown" : False,
         "tooltip" : _("Start PLC"),
         "method" : "_Run"},
        {"bitmap" : opjimg("Stop"),
         "name" : _("Stop"),
         "shown" : False,
         "tooltip" : _("Stop Running PLC"),
         "method" : "_Stop"},
        {"bitmap" : opjimg("Build"),
         "name" : _("Build"),
         "tooltip" : _("Build project into build folder"),
         "method" : "_Build"},
        {"bitmap" : opjimg("Transfer"),
         "name" : _("Transfer"),
         "shown" : False,
         "tooltip" : _("Transfer PLC"),
         "method" : "_Transfer"},
    ]

    def __init__(self, frame, logger, buildpath):
        self.OrigBuildPath = buildpath
        
        PluginsRoot.__init__(self, frame, logger)
        
        if havecanfestival:
            self.PlugChildsTypes += [("LPCBus", LPCBus, "LPC bus"), ("CanOpen", LPCCanOpen, "CanOpen bus")]
        else:
            self.PlugChildsTypes += [("LPCBus", LPCBus, "LPC bus")]
        self.PlugType = "LPC"
        
        self.OnlineMode = "OFF"
        self.LPCConnector = None
        
        self.CurrentMode = None
        self.previous_mode = None
        
        self.SimulationBuildPath = None
        
        self.AbortTransferTimer = None
    
    def PluginLibraryFilePath(self):
        if self.OrigBuildPath is not None:
            return os.path.join(self.OrigBuildPath, "pous.xml")
        else:
            return PluginsRoot.PluginLibraryFilePath(self)
    
    def GetProjectName(self):
        return self.Project.getname()

    def GetDefaultTargetName(self):
        if self.CurrentMode == SIMULATION_MODE:
            return PluginsRoot.GetDefaultTargetName(self)
        else:
            return "LPC"

    def GetTarget(self):
        target = PluginsRoot.GetTarget(self)
        if self.CurrentMode != SIMULATION_MODE:
            target.getcontent()["value"].setBuildPath(self.BuildPath)
        return target
    
    def _getBuildPath(self):
        if self.CurrentMode == SIMULATION_MODE:
            if self.SimulationBuildPath is None:
                self.SimulationBuildPath = os.path.join(tempfile.mkdtemp(), os.path.basename(self.ProjectPath), "build")
            return self.SimulationBuildPath
        else:
            return PluginsRoot._getBuildPath(self)

    def _Build(self):
        save = self.ProjectTestModified()
        if save:
            self.SaveProject()
            self.AppFrame._Refresh(TITLE, FILEMENU)
        if self.BuildPath is not None:
            mycopytree(self.OrigBuildPath, self.BuildPath)
        PluginsRoot._Build(self)
        if save:
            wx.CallAfter(self.AppFrame.RefreshAll)
    
    def SetProjectName(self, name):
        return self.Project.setname(name)

    def SetOnlineMode(self, mode, path=None):
        if self.OnlineMode != mode.upper():
            self.OnlineMode = mode.upper()
            
            if self.OnlineMode != "OFF":
                uri = "LPC://%s/%s" % (self.OnlineMode,path)
                try:
                    self.LPCConnector = connectors.ConnectorFactory(uri, self)
                except Exception, msg:
                    self.logger.write_error(_("Exception while connecting %s!\n")%uri)
                    self.logger.write_error(traceback.format_exc())

                # Did connection success ?
                if self.LPCConnector is None:
                    # Oups.
                    self.logger.write_error(_("Connection failed to %s!\n")%uri)
                
            else:
                self.LPCConnector = None
            
            self.ApplyOnlineMode()

    def ApplyOnlineMode(self):
        if self.CurrentMode != SIMULATION_MODE:
            self.KillDebugThread()
            
            self._connector = self.LPCConnector
            
            # Init with actual PLC status and print it
            self.UpdateMethodsFromPLCStatus()
                
            if self.LPCConnector is not None and self.OnlineMode == "APPLICATION":
                
                self.CompareLocalAndRemotePLC()
                            
                if self.previous_plcstate is not None:
                    status = _(self.previous_plcstate)
                else:
                    status = ""
                self.logger.write(_("PLC is %s\n")%status)
                
                #if self.StatusTimer and not self.StatusTimer.IsRunning():
                #    # Start the status Timer
                #    self.StatusTimer.Start(milliseconds=2000, oneShot=False)
                
                if self.previous_plcstate=="Started":
                    if self.DebugAvailable() and self.GetIECProgramsAndVariables():
                        self.logger.write(_("Debug connect matching running PLC\n"))
                        self._connect_debug()
                    else:
                        self.logger.write_warning(_("Debug do not match PLC - stop/transfert/start to re-enable\n"))
            
            elif self.StatusTimer and self.StatusTimer.IsRunning():
                self.StatusTimer.Stop()
            
            if self.CurrentMode == TRANSFER_MODE:
                
                if self.OnlineMode == "BOOTLOADER":
                    self.BeginTransfer()
                
                elif self.OnlineMode == "APPLICATION":
                    self.CurrentMode = None
                    self.AbortTransferTimer.Stop()
                    self.AbortTransferTimer = None
                    
                    self.logger.write(_("PLC transferred successfully\n"))
    
    # Update a PLCOpenEditor Pou variable name
    def UpdateProjectVariableName(self, old_name, new_name):
        self.Project.updateElementName(old_name, new_name)
        self.BufferProject()

    def RemoveProjectVariableByAddress(self, address):
        self.Project.removeVariableByAddress(address)
        self.BufferProject()

    def RemoveProjectVariableByFilter(self, leading):
        self.Project.removeVariableByFilter(leading)
        self.BufferProject()

    def LoadProject(self, ProjectPath, BuildPath=None):
        """
        Load a project contained in a folder
        @param ProjectPath: path of the project folder
        """
        if os.path.basename(ProjectPath) == "":
            ProjectPath = os.path.dirname(ProjectPath)
        
        # Verify that project contains a PLCOpen program
        plc_file = os.path.join(ProjectPath, "plc.xml")
        if os.path.isfile(plc_file):
            # Load PLCOpen file
            result = self.OpenXMLFile(plc_file)
            if result:
                return result
        else:
            self.CreateNewProject({"companyName": "",
                                   "productName": "",
                                   "productVersion": "",
                                   "projectName": "",
                                   "pageSize": (0, 0),
                                   "scaling": {}})
        
        # Change XSD into class members
        self._AddParamsMembers()
        self.PluggedChilds = {}
        
        # Keep track of the root plugin (i.e. project path)
        self.ProjectPath = ProjectPath
        
        self.BuildPath = self._getBuildPath()
        if self.OrigBuildPath is not None:
            mycopytree(self.OrigBuildPath, self.BuildPath)
        
        # If dir have already be made, and file exist
        if os.path.isdir(self.PlugPath()) and os.path.isfile(self.PluginXmlFilePath()):
            #Load the plugin.xml file into parameters members
            result = self.LoadXMLParams()
            if result:
                return result
            #Load and init all the childs
            self.LoadChilds()
        
        if havecanfestival and self.GetChildByName("CanOpen") is None:
            canopen = self.PlugAddChild("CanOpen", "CanOpen", 0)
            canopen.BaseParams.setEnabled(False)
            canopen.LoadChilds()
        
        if self.PlugTestModified():
            self.SaveProject()
        
        if wx.GetApp() is None:
            self.RefreshPluginsBlockLists()
        else:
            wx.CallAfter(self.RefreshPluginsBlockLists)

        return None

    ############# Real PLC object access #############
    def UpdateMethodsFromPLCStatus(self):
        # Get PLC state : Running or Stopped
        # TODO : use explicit status instead of boolean
        if self.OnlineMode == "OFF":
            status = "Disconnected"
        elif self.OnlineMode == "BOOTLOADER":
            status = "Connected"
        else:
            if self._connector is not None:
                status = self._connector.GetPLCstatus()
            else:
                status = "Disconnected"
        if self.previous_plcstate != status or self.previous_mode != self.CurrentMode:
            simulating = self.CurrentMode == SIMULATION_MODE
            for args in {
                     "Started" :     [("_Simulate", False),
                                      ("_Run", False),
                                      ("_Stop", True),
                                      ("_Build", True),
                                      ("_Transfer", True)],
                     "Stopped" :     [("_Simulate", False),
                                      ("_Run", True),
                                      ("_Stop", False),
                                      ("_Build", True),
                                      ("_Transfer", True)],
                     "Connected" :   [("_Simulate", not simulating),
                                      ("_Run", True),
                                      ("_Stop", simulating),
                                      ("_Build", True),
                                      ("_Transfer", True)],
                     "Disconnected" :[("_Simulate", not simulating),
                                      ("_Run", False),
                                      ("_Stop", simulating),
                                      ("_Build", True),
                                      ("_Transfer", False)],
                   }.get(status,[]):
                self.ShowMethod(*args)
            self.previous_plcstate = status
            self.previous_mode = self.CurrentMode
            return True
        return False

    def Generate_plc_declare_locations(self):
        """
        Declare used locations in order to simulatePLC in a black box
        """
        return """#include "iec_types_all.h"

#define __LOCATED_VAR(type, name, ...) \
type beremiz_##name;\
type *name = &beremiz_##name;

#include "LOCATED_VARIABLES.h"

#undef __LOCATED_VAR

"""

    def Generate_lpc_retain_array_sim(self):
        """
        Support for retain array in Simulation
        """
        return """/* Support for retain array */
#define USER_RETAIN_ARRAY_SIZE 2000
#define NUM_OF_COLS    3
unsigned char readOK = 0;
unsigned int foundIndex = USER_RETAIN_ARRAY_SIZE;
unsigned int retainArray[USER_RETAIN_ARRAY_SIZE][NUM_OF_COLS];

unsigned int __GetRetainData(unsigned char READ, unsigned int INDEX, unsigned int COLUMN)
{
    if(READ == 1)
    {
        if((0<=INDEX) && (INDEX<USER_RETAIN_ARRAY_SIZE) && (0<=COLUMN) && (COLUMN<NUM_OF_COLS))
        {
            readOK = 1;
            return retainArray[INDEX][COLUMN];
        }
    }

    readOK = 0;
    return 0;
}

unsigned char __SetRetainData(unsigned char WRITE, unsigned int INDEX, unsigned int WORD1, unsigned int WORD2, unsigned int WORD3)
{
    if(WRITE == 1)
    {
        if((0<=INDEX) && (INDEX<USER_RETAIN_ARRAY_SIZE))
        {
            retainArray[INDEX][0] = WORD1;
            retainArray[INDEX][1] = WORD2;
            retainArray[INDEX][2] = WORD3;
            return 1;
        }
    }
    
    return 0;
}

unsigned char __FindRetainData(unsigned char SEARCH, unsigned int START_IDX, unsigned int END_IDX, unsigned int WORD1, unsigned int WORD2, unsigned int WORD3)
{
    unsigned int i;

    if((SEARCH==1) && (0<=START_IDX) && (START_IDX<USER_RETAIN_ARRAY_SIZE) && (START_IDX<=END_IDX) && (END_IDX<USER_RETAIN_ARRAY_SIZE))
    {
        for(i=START_IDX;i<=END_IDX;i++)
        {
            if((retainArray[i][0] == WORD1) && (retainArray[i][1] == WORD2) && (retainArray[i][2] == WORD3))
            {
                foundIndex = i;
                return 1;
            }
        }
    }

    foundIndex = USER_RETAIN_ARRAY_SIZE;    /* Data not found => return index that is out of array bounds */
    return 0;
}

/* Since Beremiz debugger doesn't like pointer-by-reference stuff or global varibles, separate function is a must */
unsigned char __GetReadStatus(unsigned char dummy)
{
    return readOK;
}

unsigned int __GetFoundIndex(unsigned char dummy)
{
    return foundIndex;
}
"""

    def _Simulate(self):
        """
        Method called by user to Simulate PLC
        """
        self.CurrentMode = SIMULATION_MODE
        
        uri = "LOCAL://"
        try:
            self._connector = connectors.ConnectorFactory(uri, self)
        except Exception, msg:
            self.logger.write_error(_("Exception while connecting %s!\n")%uri)
            self.logger.write_error(traceback.format_exc())

        # Did connection success ?
        if self._connector is None:
            # Oups.
            self.logger.write_error(_("Connection failed to %s!\n")%uri)
            self.StopSimulation()
            return False
        
        buildpath = self._getBuildPath()
        
        # Eventually create build dir
        if not os.path.exists(buildpath):
            os.makedirs(buildpath)
        
        # Generate SoftPLC IEC code
        IECGenRes = self._Generate_SoftPLC()
        
         # If IEC code gen fail, bail out.
        if not IECGenRes:
            self.logger.write_error(_("IEC-61131-3 code generation failed !\n"))
            self.StopSimulation()
            return False

        # Reset variable and program list that are parsed from
        # CSV file generated by IEC2C compiler.
        self.ResetIECProgramsAndVariables()
        
        gen_result = self.PlugGenerate_C(buildpath, self.PLCGeneratedLocatedVars)
        PlugCFilesAndCFLAGS, PlugLDFLAGS, DoCalls = gen_result[:3]
        # if some files have been generated put them in the list with their location
        if PlugCFilesAndCFLAGS:
            self.LocationCFilesAndCFLAGS = [(self.GetCurrentLocation(), PlugCFilesAndCFLAGS, DoCalls)]
        else:
            self.LocationCFilesAndCFLAGS = []

        # plugin asks for some LDFLAGS
        if PlugLDFLAGS:
            # LDFLAGS can be either string
            if type(PlugLDFLAGS)==type(str()):
                self.LDFLAGS=[PlugLDFLAGS]
            #or list of strings
            elif type(PlugLDFLAGS)==type(list()):
                self.LDFLAGS=PlugLDFLAGS[:]
        else:
            self.LDFLAGS=[]
        
        # Template based part of C code generation
        # files are stacked at the beginning, as files of plugin tree root
        for generator, filename, name in [
           # debugger code
           (self.Generate_plc_debugger, "plc_debugger.c", "Debugger"),
           # init/cleanup/retrieve/publish, run and align code
           (self.Generate_plc_common_main,"plc_common_main.c","Common runtime"),
           # declare located variables for simulate in a black box
           (self.Generate_plc_declare_locations,"plc_declare_locations.c","Declare Locations"),
           # declare located variables for simulate in a black box
           (self.Generate_lpc_retain_array_sim,"lpc_retain_array_sim.c","Retain Array for Simulation")]:
            try:
                # Do generate
                code = generator()
                if code is None:
                     raise
                code_path = os.path.join(buildpath,filename)
                open(code_path, "w").write(code)
                # Insert this file as first file to be compiled at root plugin
                self.LocationCFilesAndCFLAGS[0][1].insert(0,(code_path, self.plcCFLAGS))
            except Exception, exc:
                self.logger.write_error(name+_(" generation failed !\n"))
                self.logger.write_error(traceback.format_exc())
                self.StopSimulation()
                return False
        
        # Get simulation builder
        builder = self.GetBuilder()
        if builder is None:
            self.logger.write_error(_("Fatal : cannot get builder.\n"))
            self.StopSimulation()
            return False

        # Build
        try:
            if not builder.build() :
                self.logger.write_error(_("C Build failed.\n"))
                self.StopSimulation()
                return False
        except Exception, exc:
            self.logger.write_error(_("C Build crashed !\n"))
            self.logger.write_error(traceback.format_exc())
            self.StopSimulation()
            return False

        data = builder.GetBinaryCode()
        if data is not None :
            if self._connector.NewPLC(builder.GetBinaryCodeMD5(), data, []):
                self.UnsubscribeAllDebugIECVariable()
                self.ProgramTransferred()
                if self.AppFrame is not None:
                    self.AppFrame.RefreshInstancesTree()
                    self.AppFrame.CloseObsoleteDebugTabs()
                self.logger.write(_("Transfer completed successfully.\n"))
            else:
                self.logger.write_error(_("Transfer failed\n"))
                self.StopSimulation()
                return False
        
        self._Run()
                
        if not self.StatusTimer.IsRunning():
            # Start the status Timer
            self.StatusTimer.Start(milliseconds=500, oneShot=False)
    
    def StopSimulation(self):
        self.CurrentMode = None
        self.ApplyOnlineMode()
    
    def _Stop(self):
        PluginsRoot._Stop(self)
        
        if self.CurrentMode == SIMULATION_MODE:
            self.StopSimulation()

    def CompareLocalAndRemotePLC(self):
        if self.LPCConnector is None:
            return
        # We are now connected. Update button status
        MD5 = self.GetLastBuildMD5()
        # Check remote target PLC correspondance to that md5
        if MD5 is not None and self.LPCConnector.MatchMD5(MD5):
            # warns controller that program match
            self.ProgramTransferred()

    def ResetBuildMD5(self):
        builder=self.GetBuilder()
        if builder is not None:
            builder.ResetBinaryCodeMD5(self.OnlineMode)
        
    def GetLastBuildMD5(self):
        builder=self.GetBuilder()
        if builder is not None:
            return builder.GetBinaryCodeMD5(self.OnlineMode)
        else:
            return None

    def _Transfer(self):
        if self.CurrentMode is None and self.OnlineMode != "OFF":
            self.CurrentMode = TRANSFER_MODE
            
            if PluginsRoot._Build(self):
            
                ID_ABORTTRANSFERTIMER = wx.NewId()
                self.AbortTransferTimer = wx.Timer(self.AppFrame, ID_ABORTTRANSFERTIMER)
                self.AppFrame.Bind(wx.EVT_TIMER, self.AbortTransfer, self.AbortTransferTimer)  
                
                if self.OnlineMode == "BOOTLOADER":
                    self.BeginTransfer()
                
                else:
                    self.logger.write(_("Resetting PLC\n"))
                    #self.StatusTimer.Stop()
                    self.LPCConnector.ResetPLC()
                    self.AbortTransferTimer.Start(milliseconds=5000, oneShot=True)
            
            else:
                self.CurrentMode = None
    
    def BeginTransfer(self):
        self.logger.write(_("Start PLC transfer\n"))
        
        self.AbortTransferTimer.Stop()
        PluginsRoot._Transfer(self)
        self.AbortTransferTimer.Start(milliseconds=5000, oneShot=True)
    
    def AbortTransfer(self, event):
        self.logger.write_warning(_("Timeout waiting PLC to recover\n"))
        
        self.CurrentMode = None
        self.AbortTransferTimer.Stop()
        self.AbortTransferTimer = None
        event.Skip()

    def _Run(self):
        """
        Start PLC
        """
        if self.GetIECProgramsAndVariables():
            self._connector.StartPLC()
            self.logger.write(_("Starting PLC\n"))
            self._connect_debug()
        else:
            self.logger.write_error(_("Couldn't start PLC !\n"))
        self.UpdateMethodsFromPLCStatus()

#-------------------------------------------------------------------------------
#                              LPCBeremiz Class
#-------------------------------------------------------------------------------
lpcberemiz_cmd=None

class LPCBeremiz(Beremiz):
    
    def _init_coll_FileMenu_Items(self, parent):
        AppendMenu(parent, help='', id=wx.ID_SAVE,
              kind=wx.ITEM_NORMAL, text=_(u'Save\tCTRL+S'))
        AppendMenu(parent, help='', id=wx.ID_CLOSE,
              kind=wx.ITEM_NORMAL, text=_(u'Close Tab\tCTRL+W'))
        parent.AppendSeparator()
        AppendMenu(parent, help='', id=wx.ID_PAGE_SETUP,
              kind=wx.ITEM_NORMAL, text=_(u'Page Setup'))
        AppendMenu(parent, help='', id=wx.ID_PREVIEW,
              kind=wx.ITEM_NORMAL, text=_(u'Preview'))
        AppendMenu(parent, help='', id=wx.ID_PRINT,
              kind=wx.ITEM_NORMAL, text=_(u'Print'))
        parent.AppendSeparator()
        AppendMenu(parent, help='', id=wx.ID_PROPERTIES,
              kind=wx.ITEM_NORMAL, text=_(u'Properties'))
        parent.AppendSeparator()
        AppendMenu(parent, help='', id=wx.ID_EXIT,
              kind=wx.ITEM_NORMAL, text=_(u'Quit\tCTRL+Q'))
        
        self.Bind(wx.EVT_MENU, self.OnSaveProjectMenu, id=wx.ID_SAVE)
        self.Bind(wx.EVT_MENU, self.OnCloseTabMenu, id=wx.ID_CLOSE)
        self.Bind(wx.EVT_MENU, self.OnPageSetupMenu, id=wx.ID_PAGE_SETUP)
        self.Bind(wx.EVT_MENU, self.OnPreviewMenu, id=wx.ID_PREVIEW)
        self.Bind(wx.EVT_MENU, self.OnPrintMenu, id=wx.ID_PRINT)
        self.Bind(wx.EVT_MENU, self.OnPropertiesMenu, id=wx.ID_PROPERTIES)
        self.Bind(wx.EVT_MENU, self.OnQuitMenu, id=wx.ID_EXIT)
    
        self.AddToMenuToolBar([(wx.ID_SAVE, "save.png", _(u'Save'), None),
                               (wx.ID_PRINT, "print.png", _(u'Print'), None)])
    
    def _init_ctrls(self, prnt):
        IDEFrame._init_ctrls(self, prnt)
        
        self.Bind(wx.EVT_MENU, self.OnOpenWidgetInspector, id=ID_BEREMIZINSPECTOR)
        accel = wx.AcceleratorTable([wx.AcceleratorEntry(wx.ACCEL_CTRL|wx.ACCEL_ALT, ord('I'), ID_BEREMIZINSPECTOR)])
        self.SetAcceleratorTable(accel)
        
        self.PLCConfig = wx.ScrolledWindow(id=ID_BEREMIZPLCCONFIG,
              name='PLCConfig', parent=self.LeftNoteBook, pos=wx.Point(0, 0),
              size=wx.Size(-1, -1), style=wx.TAB_TRAVERSAL|wx.SUNKEN_BORDER|wx.HSCROLL|wx.VSCROLL)
        self.PLCConfig.SetBackgroundColour(wx.WHITE)
        self.PLCConfig.Bind(wx.EVT_LEFT_DOWN, self.OnPanelLeftDown)
        self.PLCConfig.Bind(wx.EVT_SIZE, self.OnMoveWindow)
        self.LeftNoteBook.InsertPage(0, self.PLCConfig, _("Topology"), True)
        
        self.LogConsole = wx.TextCtrl(id=ID_BEREMIZLOGCONSOLE, value='',
                  name='LogConsole', parent=self.BottomNoteBook, pos=wx.Point(0, 0),
                  size=wx.Size(0, 0), style=wx.TE_MULTILINE|wx.TE_RICH2)
        self.LogConsole.Bind(wx.EVT_LEFT_DCLICK, self.OnLogConsoleDClick)
        self.BottomNoteBook.AddPage(self.LogConsole, _("Log Console"))
        
        self._init_beremiz_sizers()

    def OnCloseFrame(self, event):
        global frame
        
        if self.CheckSaveBeforeClosing(_("Close Application")):
            
            frame.Hide()
            
            self.PluginRoot.ResetAppFrame(lpcberemiz_cmd.Log)
            if self.PluginRoot.OnlineMode == 0:
                self.PluginRoot._connector = None
            
            self.PluginRoot.KillDebugThread()
            self.KillLocalRuntime()
            
            self.SaveLastState()
            
            lpcberemiz_cmd.Log.write("Closed\n")
            
        event.Veto()

    def ShowProperties(self):
        old_values = self.Controler.GetProjectProperties()
        dialog = ProjectDialog(self ,False)
        dialog.SetValues(old_values)
        if dialog.ShowModal() == wx.ID_OK:
            new_values = dialog.GetValues()
            new_values["creationDateTime"] = old_values["creationDateTime"]
            if new_values != old_values:
                self.Controler.SetProjectProperties(None, new_values)
                self._Refresh(TITLE, EDITORTOOLBAR, FILEMENU, EDITMENU, DISPLAYMENU, 
                              TYPESTREE, INSTANCESTREE, SCALING)
        dialog.Destroy()

    def RefreshFileMenu(self):
        MenuToolBar = self.Panes["MenuToolBar"]
        if self.PluginRoot is not None:
            selected = self.TabsOpened.GetSelection()
            if selected >= 0:
                graphic_viewer = isinstance(self.TabsOpened.GetPage(selected), Viewer)
            else:
                graphic_viewer = False
            if self.TabsOpened.GetPageCount() > 0:
                self.FileMenu.Enable(wx.ID_CLOSE, True)
                if graphic_viewer:
                    self.FileMenu.Enable(wx.ID_PREVIEW, True)
                    self.FileMenu.Enable(wx.ID_PRINT, True)
                    MenuToolBar.EnableTool(wx.ID_PRINT, True)
                else:
                    self.FileMenu.Enable(wx.ID_PREVIEW, False)
                    self.FileMenu.Enable(wx.ID_PRINT, False)
                    MenuToolBar.EnableTool(wx.ID_PRINT, False)
            else:
                self.FileMenu.Enable(wx.ID_CLOSE, False)
                self.FileMenu.Enable(wx.ID_PREVIEW, False)
                self.FileMenu.Enable(wx.ID_PRINT, False)
                MenuToolBar.EnableTool(wx.ID_PRINT, False)
            self.FileMenu.Enable(wx.ID_PAGE_SETUP, True)
            project_modified = self.PluginRoot.ProjectTestModified()
            self.FileMenu.Enable(wx.ID_SAVE, project_modified)
            MenuToolBar.EnableTool(wx.ID_SAVE, project_modified)
            self.FileMenu.Enable(wx.ID_PROPERTIES, True)
        else:
            self.FileMenu.Enable(wx.ID_CLOSE, False)
            self.FileMenu.Enable(wx.ID_PAGE_SETUP, False)
            self.FileMenu.Enable(wx.ID_PREVIEW, False)
            self.FileMenu.Enable(wx.ID_PRINT, False)
            MenuToolBar.EnableTool(wx.ID_PRINT, False)
            self.FileMenu.Enable(wx.ID_SAVE, False)
            MenuToolBar.EnableTool(wx.ID_SAVE, False)
            self.FileMenu.Enable(wx.ID_PROPERTIES, False)
        
    def RefreshPLCParams(self):
        self.Freeze()
        self.ClearSizer(self.PLCParamsSizer)
        
        if self.PluginRoot is not None:    
            plcwindow = wx.Panel(self.PLCConfig, -1, size=wx.Size(-1, -1))
            if self.PluginRoot.PlugTestModified():
                bkgdclr = CHANGED_TITLE_COLOUR
            else:
                bkgdclr = TITLE_COLOUR
                
            if self.PluginRoot not in self.PluginInfos:
                self.PluginInfos[self.PluginRoot] = {"right_visible" : False}
            
            plcwindow.SetBackgroundColour(TITLE_COLOUR)
            plcwindow.Bind(wx.EVT_LEFT_DOWN, self.OnPanelLeftDown)
            self.PLCParamsSizer.AddWindow(plcwindow, 0, border=0, flag=wx.GROW)
            
            plcwindowsizer = wx.BoxSizer(wx.HORIZONTAL)
            plcwindow.SetSizer(plcwindowsizer)
            
            st = wx.StaticText(plcwindow, -1)
            st.SetFont(wx.Font(faces["size"], wx.DEFAULT, wx.NORMAL, wx.BOLD, faceName = faces["helv"]))
            st.SetLabel(self.PluginRoot.GetProjectName())
            plcwindowsizer.AddWindow(st, 0, border=5, flag=wx.ALL|wx.ALIGN_CENTER)
            
            plcwindowmainsizer = wx.BoxSizer(wx.VERTICAL)
            plcwindowsizer.AddSizer(plcwindowmainsizer, 0, border=5, flag=wx.ALL)
            
            plcwindowbuttonsizer = wx.BoxSizer(wx.HORIZONTAL)
            plcwindowmainsizer.AddSizer(plcwindowbuttonsizer, 0, border=0, flag=wx.ALIGN_CENTER)
            
            msizer = self.GenerateMethodButtonSizer(self.PluginRoot, plcwindow, not self.PluginInfos[self.PluginRoot]["right_visible"])
            plcwindowbuttonsizer.AddSizer(msizer, 0, border=0, flag=wx.GROW)
            
        self.PLCConfigMainSizer.Layout()
        self.RefreshScrollBars()
        self.Thaw()

    def GenerateTreeBranch(self, plugin):
        leftwindow = wx.Panel(self.PLCConfig, -1, size=wx.Size(-1, -1))
        if plugin.PlugTestModified():
            bkgdclr=CHANGED_WINDOW_COLOUR
        else:
            bkgdclr=WINDOW_COLOUR

        leftwindow.SetBackgroundColour(bkgdclr)
        
        if plugin not in self.PluginInfos:
            self.PluginInfos[plugin] = {"expanded" : False, "left_visible" : False, "right_visible" : False}
            
        self.PluginInfos[plugin]["children"] = plugin.IECSortedChilds()
        plugin_infos = plugin.GetVariableLocationTree()
        plugin_locations = []
        if len(self.PluginInfos[plugin]["children"]) == 0:
            plugin_locations = plugin_infos["children"]
            if not self.PluginInfos[plugin].has_key("locations_infos"):
                self.PluginInfos[plugin]["locations_infos"] = {"root": {"expanded" : False}}
            
            self.PluginInfos[plugin]["locations_infos"]["root"]["left"] = None
            self.PluginInfos[plugin]["locations_infos"]["root"]["right"] = None
            self.PluginInfos[plugin]["locations_infos"]["root"]["children"] = []
        
        self.PluginTreeSizer.AddWindow(leftwindow, 0, border=0, flag=wx.GROW)
        
        leftwindowvsizer = wx.BoxSizer(wx.VERTICAL)
        leftwindow.SetSizer(leftwindowvsizer)
        
        leftwindowsizer = wx.BoxSizer(wx.HORIZONTAL)
        leftwindowvsizer.AddSizer(leftwindowsizer, 0, border=0, flag=0)
        
        self.GenerateEnableButton(leftwindow, leftwindowsizer, plugin)
        
        st = wx.StaticText(leftwindow, -1)
        st.SetFont(wx.Font(faces["size"], wx.DEFAULT, wx.NORMAL, wx.BOLD, faceName = faces["helv"]))
        st.SetLabel(plugin.GetFullIEC_Channel())
        leftwindowsizer.AddWindow(st, 0, border=5, flag=wx.RIGHT)
        
        expandbutton_id = wx.NewId()
        expandbutton = wx.lib.buttons.GenBitmapToggleButton(id=expandbutton_id, bitmap=wx.Bitmap(Bpath( 'images', 'plus.png')),
              name='ExpandButton', parent=leftwindow, pos=wx.Point(0, 0),
              size=wx.Size(13, 13), style=wx.NO_BORDER)
        expandbutton.labelDelta = 0
        expandbutton.SetBezelWidth(0)
        expandbutton.SetUseFocusIndicator(False)
        expandbutton.SetBitmapSelected(wx.Bitmap(Bpath( 'images', 'minus.png')))
            
        if len(self.PluginInfos[plugin]["children"]) > 0:
            expandbutton.SetToggle(self.PluginInfos[plugin]["expanded"])
            def togglebutton(event):
                if expandbutton.GetToggle():
                    self.ExpandPlugin(plugin)
                else:
                    self.CollapsePlugin(plugin)
                self.PluginInfos[plugin]["expanded"] = expandbutton.GetToggle()
                self.PLCConfigMainSizer.Layout()
                self.RefreshScrollBars()
                event.Skip()
            expandbutton.Bind(wx.EVT_BUTTON, togglebutton, id=expandbutton_id)
        elif len(plugin_locations) > 0:
            locations_infos = self.PluginInfos[plugin]["locations_infos"]
            expandbutton.SetToggle(locations_infos["root"]["expanded"])
            def togglebutton(event):
                if expandbutton.GetToggle():
                    self.ExpandLocation(locations_infos, "root")
                else:
                    self.CollapseLocation(locations_infos, "root")
                self.PluginInfos[plugin]["expanded"] = expandbutton.GetToggle()
                locations_infos["root"]["expanded"] = expandbutton.GetToggle()
                self.PLCConfigMainSizer.Layout()
                self.RefreshScrollBars()
                event.Skip()
            expandbutton.Bind(wx.EVT_BUTTON, togglebutton, id=expandbutton_id)
        else:
            expandbutton.Enable(False)
        leftwindowsizer.AddWindow(expandbutton, 0, border=5, flag=wx.RIGHT|wx.ALIGN_CENTER_VERTICAL)
        
        sb = wx.StaticBitmap(leftwindow, -1)
        icon = plugin_infos.get("icon", None)
        if icon is None:
            icon_bitmap = self.LocationImageList.GetBitmap(self.LocationImageDict[plugin_infos["type"]])
        else: 
            icon_bitmap = wx.Bitmap(icon)
        sb.SetBitmap(icon_bitmap)
        leftwindowsizer.AddWindow(sb, 0, border=5, flag=wx.RIGHT|wx.ALIGN_CENTER_VERTICAL)
        
        st_id = wx.NewId()
        st = wx.StaticText(leftwindow, st_id, size=wx.DefaultSize, style=wx.NO_BORDER)
        st.SetFont(wx.Font(faces["size"] * 0.75, wx.DEFAULT, wx.NORMAL, wx.BOLD, faceName = faces["helv"]))
        st.SetLabel(plugin.MandatoryParams[1].getName())
        leftwindowsizer.AddWindow(st, 0, border=5, flag=wx.RIGHT|wx.ALIGN_CENTER_VERTICAL)
        
        rightwindow = self.GenerateParamsPanel(plugin, bkgdclr)
        self.PluginTreeSizer.AddWindow(rightwindow, 0, border=0, flag=wx.GROW)

        self.PluginInfos[plugin]["left"] = leftwindow
        self.PluginInfos[plugin]["right"] = rightwindow
        for child in self.PluginInfos[plugin]["children"]:
            self.GenerateTreeBranch(child)
            if not self.PluginInfos[child]["expanded"]:
                self.CollapsePlugin(child)
        
        if len(plugin_locations) > 0:
            locations_infos = self.PluginInfos[plugin]["locations_infos"]
            treectrl = wx.TreeCtrl(self.PLCConfig, -1, size=wx.DefaultSize, 
                                   style=wx.TR_HAS_BUTTONS|wx.TR_SINGLE|wx.NO_BORDER|wx.TR_HIDE_ROOT|wx.TR_NO_LINES|wx.TR_LINES_AT_ROOT)
            treectrl.SetImageList(self.LocationImageList)
            treectrl.Bind(wx.EVT_TREE_BEGIN_DRAG, self.GenerateLocationBeginDragFunction(locations_infos))
            treectrl.Bind(wx.EVT_TREE_ITEM_EXPANDED, self.GenerateLocationExpandCollapseFunction(locations_infos, True))
            treectrl.Bind(wx.EVT_TREE_ITEM_COLLAPSED, self.GenerateLocationExpandCollapseFunction(locations_infos, False))
            
            treectrl.AddRoot("")
            self.PluginTreeSizer.AddWindow(treectrl, 0, border=0, flag=0)
            
            rightwindow = wx.Panel(self.PLCConfig, -1, size=wx.Size(-1, -1))
            rightwindow.SetBackgroundColour(wx.WHITE)
            self.PluginTreeSizer.AddWindow(rightwindow, 0, border=0, flag=wx.GROW)
            
            locations_infos["root"]["left"] = treectrl
            locations_infos["root"]["right"] = rightwindow
            for location in plugin_locations:
                locations_infos["root"]["children"].append("root.%s" % location["name"])
                self.GenerateLocationTreeBranch(treectrl, treectrl.GetRootItem(), locations_infos, "root", location)
            if locations_infos["root"]["expanded"]:
                self.ExpandLocation(locations_infos, "root")

class StdoutPseudoFile:
    
    def __init__(self, port):
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.socket.connect(('localhost', port))
        self.Buffer = ""
    
    def __del__(self):
        self.socket.close()
    
    def readline(self):
        idx = self.Buffer.find("\n")
        if idx == -1:
            self.Buffer += self.socket.recv(2048)
            idx = self.Buffer.find("\n")
        if idx != -1:
            line = self.Buffer[:idx+1]
            self.Buffer = self.Buffer[idx+1:]
            if BMZ_DBG:
                print "command >"+line
            return line
        return ""
    
    """ Base class for file like objects to facilitate StdOut for the Shell."""
    def write(self, s, style = None):
        if s != '':
            self.socket.send(s.encode('utf8'))
        
    def writeyield(self, s):
        self.write(s)

    def write_warning(self, s):
        self.write(s)

    def write_error(self, s):
        self.write(s)

    def flush(self):
        pass
    
    def isatty(self):
        return False

if __name__ == '__main__':
    
    from threading import Thread, Timer, Semaphore
    import cmd

    wx_eval_lock = Semaphore(0)
    eval_res = None
    def wx_evaluator(callable, *args, **kwargs):
        global eval_res
        eval_res = None
        try:
            eval_res=callable(*args,**kwargs)
        finally:
            wx_eval_lock.release()

    def evaluator(callable, *args, **kwargs):
        global eval_res
        wx.CallAfter(wx_evaluator,callable,*args,**kwargs)
        wx_eval_lock.acquire()
        return eval_res

    # Command log for debug, for viewing from wxInspector
    if BMZ_DBG:
        __builtins__.cmdlog = []

    class LPCBeremiz_Cmd(cmd.Cmd):
        
        prompt = ""
        RefreshTimer = None
        
        def __init__(self, PluginRoot, Log):
            cmd.Cmd.__init__(self, stdin=Log, stdout=Log)
            self.use_rawinput = False
            self.Log = Log
            self.PluginRoot = PluginRoot
            
        def RestartTimer(self):
            if self.RefreshTimer is not None:
                self.RefreshTimer.cancel()
            self.RefreshTimer = Timer(0.1, wx.CallAfter, args = [self.Refresh])
            self.RefreshTimer.start()
        
        def Exit(self):
            global frame, app
            self.Close()
            app.ExitMainLoop()
            return True
        
        def do_EOF(self, line):
            return self.Exit()
        
        def Show(self):
            global frame
            if frame is not None:
                self.PluginRoot.SetAppFrame(frame, frame.Log)
                frame.Show()
                frame.Raise()
        
        def Refresh(self):
            global frame
            if frame is not None:
                frame._Refresh(TITLE, INSTANCESTREE, FILEMENU, EDITMENU)
                frame.RefreshEditor()
                frame.RefreshAll()
        
        def Close(self):
            global frame
            
            self.PluginRoot.ResetAppFrame(self.Log)
            if frame is not None:
                frame.Hide()
        
        def Compile(self):
            self.PluginRoot._Build()
        
        def SetProjectProperties(self, projectname, productname, productversion, companyname):
            properties = self.PluginRoot.GetProjectProperties()
            new_properties = properties.copy()
            new_properties["projectName"] = projectname
            new_properties["productName"] = productname
            new_properties["productVersion"] = productversion
            new_properties["companyName"] = companyname
            if new_properties != properties:
                self.PluginRoot.SetProjectProperties(properties=new_properties, buffer=False)
                self.RestartTimer()
        
        def SetOnlineMode(self, mode, path=None):
            self.PluginRoot.SetOnlineMode(mode, path)
            self.RestartTimer()
        
        def AddBus(self, iec_channel, name, icon=None):
            for child in self.PluginRoot.IterChilds():
                if child.BaseParams.getName() == name:
                    return "Error: A bus named %s already exists\n" % name
                elif child.BaseParams.getIEC_Channel() == iec_channel:
                    return "Error: A bus with IEC_channel %d already exists\n" % iec_channel
            bus = self.PluginRoot.PlugAddChild(name, "LPCBus", iec_channel)
            if bus is None:
                return "Error: Unable to create bus\n"
            bus.SetIcon(icon)
            self.RestartTimer()
        
        def RenameBus(self, iec_channel, name):
            bus = self.PluginRoot.GetChildByIECLocation((iec_channel,))
            if bus is None:
                return "Error: No bus found\n"
            for child in self.PluginRoot.IterChilds():
                if child != bus and child.BaseParams.getName() == name:
                    return "Error: A bus named %s already exists\n" % name
            bus.BaseParams.setName(name)
            self.RestartTimer()
        
        def ChangeBusIECChannel(self, old_iec_channel, new_iec_channel):
            bus = self.PluginRoot.GetChildByIECLocation((old_iec_channel,))
            if bus is None:
                return "Error: No bus found\n"
            for child in self.PluginRoot.IterChilds():
                if child != bus and child.BaseParams.getIEC_Channel() == new_iec_channel:
                    return "Error: A bus with IEC_channel %d already exists\n" % new_iec_channel
            if wx.GetApp() is None:
                self.PluginRoot.UpdateProjectVariableLocation(str(old_iec_channel), 
                                                              str(new_iec_channel))
            else:
                self.PluginRoot.UpdateProjectVariableLocation(
                             str(old_iec_channel), 
                             str(new_iec_channel))
            bus.BaseParams.setIEC_Channel(new_iec_channel)
            self.RestartTimer()
        
        def RemoveBus(self, iec_channel):
            bus = self.PluginRoot.GetChildByIECLocation((iec_channel,))
            if bus is None:
                return "Error: No bus found\n"
            self.PluginRoot.RemoveProjectVariableByFilter(str(iec_channel))
            self.PluginRoot.PluggedChilds["LPCBus"].remove(bus)
            self.RestartTimer()
    
        def AddModule(self, parent, iec_channel, name, icode, icon=None):
            module = self.PluginRoot.GetChildByIECLocation(parent)
            if module is None:
                return "Error: No parent found\n"
            for child in _GetModuleChildren(module):
                if child["name"] == name:
                    return "Error: A module named %s already exists\n" % name
                elif child["IEC_Channel"] == iec_channel:
                    return "Error: A module with IEC_channel %d already exists\n" % iec_channel 
            _GetLastModuleGroup(module).append({"name": name, 
                                                "type": LOCATION_MODULE, 
                                                "IEC_Channel": iec_channel, 
                                                "icon": icon, 
                                                "init": icode, 
                                                "children": []})
            self.RestartTimer()
    
        def RenameModule(self, iec_location, name):
            module = self.PluginRoot.GetChildByIECLocation(iec_location)
            if module is None:
                return "Error: No module found\n"
            parent = self.PluginRoot.GetChildByIECLocation(iec_location[:-1])
            if parent is self.PluginRoot:
                return "Error: No module found\n"
            if module["name"] != name:
                for child in _GetModuleChildren(parent):
                    if child["name"] == name:
                        return "Error: A module named %s already exists\n" % name
                module["name"] = name
            self.RestartTimer()
    
        def ChangeModuleIECChannel(self, old_iec_location, new_iec_channel):
            module = self.PluginRoot.GetChildByIECLocation(old_iec_location)
            if module is None:
                return "Error: No module found\n"
            parent = self.PluginRoot.GetChildByIECLocation(old_iec_location[:-1])
            if parent is self.PluginRoot:
                return "Error: No module found\n"
            if module["IEC_Channel"] != new_iec_channel:
                for child in _GetModuleChildren(parent):
                    if child["IEC_Channel"] == new_iec_channel:
                        return "Error: A module with IEC_channel %d already exists\n" % new_iec_channel
            self.PluginRoot.UpdateProjectVariableLocation(".".join(map(str, old_iec_location)), ".".join(map(str, old_iec_location[:1] + (new_iec_channel,))))
            module["IEC_Channel"] = new_iec_channel
            self.RestartTimer()
        
        def ChangeModuleInitCode(self, iec_location, icode):
            module = self.PluginRoot.GetChildByIECLocation(iec_location)
            if module is None:
                return "Error: No module found\n"
            module["init"] = icode
        
        def RemoveModule(self, parent, iec_channel):
            module = self.PluginRoot.GetChildByIECLocation(parent)
            if module is None:
                return "Error: No parent found\n"
            child = _GetModuleBySomething(module, "IEC_Channel", (iec_channel,))
            if child is None:
                return "Error: No module found\n"
            self.PluginRoot.RemoveProjectVariableByFilter(".".join(map(str, parent + (iec_channel,))))
            _RemoveModuleChild(module, child)
            self.RestartTimer()
        
        def StartGroup(self, parent, name, icon=None):
            module = self.PluginRoot.GetChildByIECLocation(parent)
            if module is None:
                return "Error: No parent found\n"
            for child in module["children"]:
                if child["type"] == LOCATION_GROUP and child["name"] == name:
                    return "Error: A group named %s already exists\n" % name
            module["children"].append({"name": name, 
                                      "type": LOCATION_GROUP, 
                                      "icon": icon, 
                                      "children": []})
            self.RestartTimer()
    
        def AddVariable(self, parent, location, name, direction, type, rcode, pcode, description=""):
            module = self.PluginRoot.GetChildByIECLocation(parent)
            if module is None:
                return "Error: No parent found\n"
            for child in _GetModuleChildren(module):
                if child["name"] == name:
                    return "Error: A variable named %s already exists\n" % name
                if child["location"] == location and child["type"] == LOCATION_TYPES[direction]:
                    return "Error: A variable with location %s already exists\n" % ".".join(map(str, location))
            _GetLastModuleGroup(module).append({"name": name, 
                                                "location": location, 
                                                "type": LOCATION_TYPES[direction], 
                                                "IEC_type": type, 
                                                "description": description, 
                                                "retrieve": rcode, 
                                                "publish": pcode})
            self.RestartTimer()

        def ChangeVariableParams(self, parent, location, new_name, new_direction, new_type, new_rcode, new_pcode, new_description=None):
            module = self.PluginRoot.GetChildByIECLocation(parent)
            if module is None:
                return "Error: No parent found\n"
            variable = None
            for child in _GetModuleChildren(module):
                if child["location"] == location and child["type"] == LOCATION_TYPES[new_direction]:
                    variable = child
                elif child["name"] == new_name:
                    return "Error: A variable named %s already exists\n" % new_name
            if variable is None:
                return "Error: No variable found\n"
            if variable["name"] != new_name:
                self.PluginRoot.UpdateProjectVariableName(variable["name"], new_name)
                variable["name"] = new_name
            variable["type"] = LOCATION_TYPES[new_direction]
            variable["IEC_type"] = new_type
            variable["retrieve"] = new_rcode
            variable["publish"] = new_pcode
            if new_description is not None:
                variable["description"] = new_description
            self.RestartTimer()
    
        def RemoveVariable(self, parent, location, direction):
            module = self.PluginRoot.GetChildByIECLocation(parent)
            if module is None:
                return "Error: No parent found\n"
            child = _GetModuleVariable(module, location, direction)
            if child is None:
                return "Error: No variable found\n"
            size = LOCATION_SIZES[self.PluginRoot.GetBaseType(child["IEC_type"])]
            address = "%" + LOCATION_DIRS[child["type"]] + size + ".".join(map(str, parent + location))
            self.PluginRoot.RemoveProjectVariableByAddress(address)
            _RemoveModuleChild(module, child)
            self.RestartTimer()
        
    def location(loc):
        return tuple(map(int, loc.split(".")))
    
    def GetCmdFunction(function, arg_types, opt=0):
        arg_number = len(arg_types)
        def CmdFunction(self, line):
            args_toks = line.split('"')
            if len(args_toks) % 2 == 0:
                self.Log.write("Error: Invalid command\n")
                sys.stdout.flush()
                return
            args = []
            for num, arg in enumerate(args_toks):
                if num % 2 == 0:
                    stripped = arg.strip()
                    if stripped:
                        args.extend(stripped.split(" "))
                else:
                    args.append(arg)
            number = None
            extra = ""
            if opt == 0 and len(args) != arg_number:
                number = arg_number
            elif len(args) > arg_number:
                number = arg_number
                extra = " at most"
            elif len(args) < arg_number - opt:
                number = arg_number - opt
                extra = " at least"
            if number is not None:
                if number == 0:
                    self.Log.write("Error: No argument%s expected\n" % extra)
                elif number == 1:
                    self.Log.write("Error: 1 argument%s expected\n" % extra)
                else:
                    self.Log.write("Error: %d arguments%s expected\n" % (number, extra))
                sys.stdout.flush()
                return
            for num, arg in enumerate(args):
                try:
                    args[num] = arg_types[num](arg)
                except:
                    self.Log.write("Error: Invalid value for argument %d\n" % (num + 1))
                    sys.stdout.flush()
                    return

            func = getattr(self, function)
            res = evaluator(func,*args)

            if BMZ_DBG:
                cmdlog.append((function,line,res))
                if len(cmdlog) > 100: #prevent debug log to grow too much
                    cmdlog.pop(0) 

            if isinstance(res, (StringType, UnicodeType)):
                self.Log.write(res)
                return False
            else:
                return res
        return CmdFunction

    def CmdThreadProc(PluginRoot, Log):
        global lpcberemiz_cmd
        for function, (arg_types, opt) in {"Exit": ([], 0),
                                           "Show": ([], 0),
                                           "Refresh": ([], 0),
                                           "Close": ([], 0),
                                           "Compile": ([], 0),
                                           "SetProjectProperties": ([str, str, str, str], 0),
                                           "SetOnlineMode": ([str, str], 1),
                                           "AddBus": ([int, str, str], 1),
                                           "RenameBus": ([int, str], 0),
                                           "ChangeBusIECChannel": ([int, int], 0),
                                           "RemoveBus": ([int], 0),
                                           "AddModule": ([location, int, str, str, str], 1), 
                                           "RenameModule": ([location, str], 0),
                                           "ChangeModuleIECChannel": ([location, int], 0),
                                           "ChangeModuleInitCode": ([location, str], 0),
                                           "RemoveModule": ([location, int], 0),
                                           "StartGroup": ([location, str, str], 1),
                                           "AddVariable": ([location, location, str, str, str, str, str, str], 1),
                                           "ChangeVariableParams": ([location, location, str, str, str, str, str, str], 1),
                                           "RemoveVariable": ([location, location], 0)}.iteritems():
            
            setattr(LPCBeremiz_Cmd, "do_%s" % function, GetCmdFunction(function, arg_types, opt))
        lpcberemiz_cmd = LPCBeremiz_Cmd(PluginRoot, Log)
        lpcberemiz_cmd.cmdloop()

    Log = StdoutPseudoFile(port)

    PluginRoot = LPCPluginsRoot(None, Log, buildpath)
    if projectOpen is not None and os.path.isdir(projectOpen):
        result = PluginRoot.LoadProject(projectOpen)
        if result:
            Log.write("Error: Invalid project directory", result)
    else:
        Log.write("Error: No such file or directory")
    
    cmd_thread=Thread(target=CmdThreadProc, args=[PluginRoot, Log])
    cmd_thread.start()

    # Install a exception handle for bug reports
    AddExceptHook(os.getcwd(),__version__)
    
    frame = LPCBeremiz(None, plugin_root=PluginRoot, debug=True)
    
    app.MainLoop()
    
